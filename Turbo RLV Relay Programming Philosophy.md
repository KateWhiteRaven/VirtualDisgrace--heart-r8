#### Turbo RLV Relay Programming Philosophy

Programming for Turbo RLV Relay requires a pathological commitment to performance. There is no argument for not coding efficiently.

A little example. If you have ever driven a Lexus, you know that the car was designed and built with the highest commitment to quality. Every piece fits, everything works consistently, and the car seems to last forever. Now, if you drive a General Motors car, like a Chevrolet or Pontiac, you will notice that the car does not have a fit and finish. It works, but only so much as you are constantly trying to put money into it. Some cars last, but most others from the same make and year don't. It's very inconsistent. Lexus cars are built with a very very high standard, whereas GM cars are built by accountants: with the cheapest and most time-saving available components and techniques.

We are not GM. We do not code "cheaply". We do not “throw it together". We do the research, we do the optimizing, we make this the best relay out there!

This commitment to performance is the only thing that sets this relay apart from the pack. And here are the requirements to make a “Turbo” Relay.

##### Performance

The Turbo RLV Relay was originally conceived and designed as a high performance relay. The current set of relays are 40 to 500 percent slower than the Turbo Relay at the basic tasks of adding, managing, and removing restrictions. This is not network delay, but processing overhead, which, when multiplied out, can slow down already loaded sims.

To fully understand the core concept, think of the RLV Relay as a router to your viewer. It performs the same functions, directing traffic from a public network to the private one, filtering out the unwanted stuff. If you had a router on your internet that was slow, would you not want to replace it with a faster one? Many gamers buy expensive, high-end routers for the very reason that they reduce lag by running more efficiently. The same can be said of the Relay. "But Da," you say, "Most people don't care about speed!" Here we go with the not-a-priority argument again. See, that line of thinking is how current relays got to where they are now. Let's load them with features, and make them absolutely bulletproof, but forget completely about coding for speed. However, with slow code comes timing issues. Objects that are relying on the relay having a fast turnaround time get broken, and broken content means unsatisfied players. It also increases the server load, as more users get on and are using their RLV Relays. Even if its only fractions of a second, those fractions add up.

The core of the relay is one script, and only one script. All the TIME CRITICAL processes (from receiving commands to cleaning up the data) are in a single script. All the interface options are in an auxillary script, to lower the memory and processing overhead with the relay script, and the update checker in a third script with a very, very low memory limit, only to prevent delays with operation, since it uses llEmail() to check updates. Only due to script memory limits does the Turbo Safety RLV Relay use an additional "Queue" script, which is carefully coded so as to perform almost as quickly as without this additional script.

All the methods and processes in the script used are tested and benchmarked to be the fastest methods possible. For example, many relays store all the objects and commands in a strided list, and use lots of string and list indexing and searching to manage the RLV Restrictions. Turbo searches and calls as few times as is possible, and stores results in temp vars, so that repeat operations (such as if(~llListFindList(source,["option"])) do_something(llListFindList(copypasta)) does not slow down processing. In fact, every command is broken up into three strings (command,:param,=option), which are compared to find the wanted results. String comparison is infinitesimally faster than any other operation (string search, list search). There are also other list optimizations. Any time a list is constructed in-code, even an empty list [], that takes significant time and bytecode. Constants or variables are used anywhere a list can be set as such. This includes null list checks, such as if(list==[]), which now uses a Constant called NULL_LIST, set to []. This makes if(list==NULL_LIST) as fast as any other variable comparison, which is near instant.

In addition, the relay also takes shortcuts if there is only one active controller. When there are multiple controllers, the relay has to merge the restrictions and manage the removal of them. These extra checks are not required if there is only one object controlling, and the relay is very carefully coded so that there are no errors arising from it. These shortcuts allow the relay to perform with the kind of speed one can get out of a single object relay, and yet, the relay can still perform even when managing two or three objects at once. It is also of note that the relay preserves command order, and does not respond to the in-world object until it has completed its task. This prevents desynchronization errors found in some other relays, where a separate message handler is confirming or denying restrictions before they are applied viewer side.

The link_message event is very tightly controlled. The relay only sends link messages to the necessary prims, and conversely, the interface script only sends link messages to other prims. This means the relay and the interface script must be in different prims. In addition, the interface script is designed to work in the Root Prim only, since it is the sole handler of Touch events.

The interface is controlled entirely from HUD Buttons. The HUD itself contains no textured buttons. This is intentional, to reduce the bandwidth overhead and visibly speed up the HUD's updates to the user.

##### Memory Usage

While we know that Mono only uses "up to" the limit of memory, but memory detectors still report the allocated memory usage. Current relays can have from 384kb to 896kb of allocated memory. Turbo RLV Relay stays under 136kb. This is important for combat sims that not only use RLV but require a very low memory usage, or deny players from entering by using said memory detector, in order to minimize lag.

The entire relay must have as few scripts as possible. Instead of adding another script to perform a function, integrate it into the "interface" script. If you stackheap the interface script, maybe its time to rethink your feature addition. And don't forget to integrate it cleanly into interface. Look at how the existing features are handled, and make sure it works likewise.

##### Modularity

The second biggest advantage to Turbo RLV Relay is its modularity. If you accidentally delink the whole HUD, and graft it together Frankenstein-like, the interface script will not be broken, and all the buttons will still work, as long as the root prim is properly defined. If you yank out the turbo_relay script and put it in your own HUD, it will not damage it. For example, if you decide you don't want the Safeword Disable button, you can delink and delete it, and it will function just fine.

While the relay script is coded for absolute speed, the interface script can take a few liberties, as long as it does not cause perceptible lag when pressing the buttons. For example, every button has a variable, that stores its link number. When you start the relay (the relay does a light-up animation), it has a built-in Power-On Self Test (POST) that scans all the link names, and assigns the appropriate buttons to their variables. If it does not exist, it ignores that functionality entirely. When adding additional buttons, this design must be adhered to. Taking liberties or making assumptions will cause problems if the HUD is customized by the user. If the user wants to integrate Turbo Relay into their own HUD, all they need is to interface with it using the proper link messages. If they don't, the Relay simply works as a fully automatic, silent, safewordless relay.